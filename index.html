<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Linear Actuator Solver</title>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #000;
            color: #ddd;
        }

        h1 {
            margin: 0 0 10px 0;
        }

        .panel {
            background: #111;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .controls {
            width: 260px;
        }

        label {
            display: block;
            margin: 6px 0 2px;
        }

        input, select {
            width: 100%;
            padding: 6px;
            background: #222;
            border: 1px solid #444;
            color: #eee;
            border-radius: 4px;
        }

        #canvas {
            width: 100%;
            max-width: 1000px;
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            display: block;
            margin: auto;
            cursor: default;
        }

        .small {
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.4em;
        }

        .eq {
            line-height: 1.4em;
        }

        .hidden {
            display: none;
        }

        .math-block {
            margin-top: 10px;
        }

        .math-block h3 {
            margin-bottom: 4px;
        }

        .inline-row {
            display: flex;
            gap: 8px;
        }

        .inline-row > div {
            flex: 1;
        }
    </style>
</head>
<body>

<h1>Linear Actuator Solver</h1>

<div class="panel">
    <div class="row">

        <div class="controls">
            <label>Mode</label>
            <select id="mode">
                <option value="driven">Driven mode (circle intersection)</option>
                <option value="axis">Axis mode (AC, BC, ∠C)</option>
            </select>

            <!-- Checkbox with label left, checkbox right -->
            <label style="margin-top:12px; display:flex; flex-direction:row; align-items:center; justify-content:space-between; gap:8px;">
                <span>Show debug (grid, circles)</span>
                <input type="checkbox" id="showDebug" checked />
            </label>

            <hr style="border-color:#333; margin:12px 0;">

            <h3>Common</h3>
            <label>Base AC length</label>
            <input id="lenAC" type="number" value="8" step="0.1"/>

            <div id="drivenControls">
                <h3 style="margin-top:16px;">Driven mode (circles)</h3>
                <label>Radius AB (circle at A)</label>
                <input id="radA" type="number" value="7.1" step="0.1"/>8

                <label>Radius CB (circle at C)</label>
                <input id="radC" type="number" value="3.2" step="0.1"/>
            </div>

            <div id="axisControls" class="hidden">
                <h3 style="margin-top:16px;">Axis mode</h3>
                <label>Length BC</label>
                <input id="lenBC" type="number" value="6" step="0.1"/>

                <label>Angle at C (degrees)</label>
                <input id="angleC" type="number" value="40" step="0.1"/>
            </div>

            <div class="panel small" style="margin-top:16px;">
                <h3>Tutorial</h3>
                <p>
                    This visualiser shows how a linear actuator (or sliding joint) can be understood as a
                    triangle between three key points:
                </p>
                <ul>
                    <li>Points A and C lie on a fixed baseline (the mounting points).</li>
                    <li>Point B is the moving joint where the actuator connects to the structure.</li>
                    <li>
                        In <strong>Driven mode</strong>, B is found as the intersection of two circles:
                        one around A with radius AB, and one around C with radius CB.
                    </li>
                    <li>
                        In <strong>Axis mode</strong>, you specify BC and the angle at C, and B is
                        computed from AC, BC, and ∠C.
                    </li>
                    <li>Use the debug view to see construction circles and the grid.</li>
                </ul>
                <p>
                    The triangle ABC is then used to compute all side lengths and internal angles,
                    which can map directly to actuator stroke and joint angles in your rig.
                </p>
            </div>
        </div>

        <div style="flex:1; min-width:300px; display:flex; align-items:stretch;">
            <canvas id="canvas"></canvas>
        </div>

    </div>
</div>

<div class="panel" id="results"></div>

<script>
    // ---------- helpers ----------
    function toRad(d) { return d * Math.PI / 180; }
    function toDeg(r) { return r * 180 / Math.PI; }

    function dist(p, q) {
        const dx = q.x - p.x, dy = q.y - p.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    // Circle–circle intersection in Y-up world
    function circleIntersect(A, r1, C, r2) {
        const d = dist(A, C);
        if (d === 0 && r1 === r2) return null;          // infinite solutions
        if (d > r1 + r2) return null;                   // too far apart
        if (d < Math.abs(r1 - r2)) return null;         // one inside other

        const a = (r1*r1 - r2*r2 + d*d) / (2*d);
        const h2 = r1*r1 - a*a;
        if (h2 < 0) return null;
        const h = Math.sqrt(h2);

        const xm = A.x + a * (C.x - A.x) / d;
        const ym = A.y + a * (C.y - A.y) / d;

        const rx = -(C.y - A.y) * (h / d);
        const ry =  (C.x - A.x) * (h / d);

        const p1 = { x: xm + rx, y: ym + ry };
        const p2 = { x: xm - rx, y: ym - ry };

        return { p1, p2, d, a, h, xm, ym };
    }

    // ---------- DOM ----------
    const canvas = document.getElementById("canvas");
    const ctx     = canvas.getContext("2d");
    const modeEl  = document.getElementById("mode");
    const showDebugEl = document.getElementById("showDebug");

    const lenACEl = document.getElementById("lenAC");
    const radAEl  = document.getElementById("radA");
    const radCEl  = document.getElementById("radC");
    const lenBCEl = document.getElementById("lenBC");
    const angleCEl = document.getElementById("angleC");

    const drivenControls = document.getElementById("drivenControls");
    const axisControls   = document.getElementById("axisControls");
    const resultsPanel   = document.getElementById("results");

    // ---------- main update ----------
    function update() {
        const mode = modeEl.value;
        drivenControls.classList.toggle("hidden", mode !== "driven");
        axisControls.classList.toggle("hidden", mode !== "axis");

        const AC = parseFloat(lenACEl.value);
        if (!(AC > 0)) {
            resultsPanel.innerHTML = "<h2>Results</h2>Base AC must be > 0.";
            clearCanvas();
            return;
        }

        const A = { x: 0,   y: 0 };
        const C = { x: AC,  y: 0 };
        let B = null;
        let debugData = {};

        if (mode === "driven") {
            const rA = parseFloat(radAEl.value);
            const rC = parseFloat(radCEl.value);
            if (!(rA > 0 && rC > 0)) {
                resultsPanel.innerHTML = "<h2>Results</h2>Radii must be > 0.";
                clearCanvas();
                return;
            }
            const I = circleIntersect(A, rA, C, rC);
            if (!I) {
                resultsPanel.innerHTML = "<h2>Results</h2>No intersection for these radii.";
                clearCanvas();
                return;
            }
            // choose intersection above baseline (largest y)
            B = (I.p1.y >= I.p2.y) ? I.p1 : I.p2;
            debugData = { mode, A, B, C, rA, rC, I };
        } else { // axis mode
            const BC = parseFloat(lenBCEl.value);
            const angleC = parseFloat(angleCEl.value);
            if (!(BC > 0)) {
                resultsPanel.innerHTML = "<h2>Results</h2>BC must be > 0.";
                clearCanvas();
                return;
            }
            if (!(angleC > 0 && angleC < 180)) {
                resultsPanel.innerHTML = "<h2>Results</h2>Angle C must be between 0 and 180°.";
                clearCanvas();
                return;
            }

            const ang = toRad(angleC);
            // B computed so that angle at C between CA and CB is angleC, B above baseline
            B = {
                x: C.x - BC * Math.cos(ang),
                y:      BC * Math.sin(ang)
            };
            debugData = { mode, A, B, C, BC, angleC };
        }

        // Compute triangle metrics
        const AB = dist(A, B);
        const BC = dist(B, C);
        const ACd = dist(A, C); // same as AC, but computed

        // Angles using cosine rule
        const angleA = toDeg(Math.acos(
            (AB*AB + ACd*ACd - BC*BC) / (2*AB*ACd)
        ));
        const angleB = toDeg(Math.acos(
            (AB*AB + BC*BC - ACd*ACd) / (2*AB*BC)
        ));
        const angleCtri = 180 - angleA - angleB;

        // Results text
        let html = `<h2>Results</h2>
        <p>Mode: <strong>${mode === "driven" ? "Driven (circles)" : "Axis (AC, BC, ∠C)"}</strong></p>
        <p>AB = ${AB.toFixed(3)}, BC = ${BC.toFixed(3)}, AC = ${ACd.toFixed(3)}</p>
        <p>∠A = ${angleA.toFixed(2)}°, ∠B = ${angleB.toFixed(2)}°, ∠C = ${angleCtri.toFixed(2)}°</p>
        `;

        if (mode === "driven") {
            const { rA, rC, I } = debugData;
            html += `
            <h3>Driven mode (circle intersection)</h3>
            <div class="eq small">
                <p>Circle 1: centre A, radius r₁ = AB = ${rA.toFixed(3)}</p>
                <p>Circle 2: centre C, radius r₂ = CB = ${rC.toFixed(3)}</p>
                <p>Distance between centres: d = ${I.d.toFixed(3)}</p>
                <p>a = (r₁² − r₂² + d²) / (2d)</p>
                <p>h = √(r₁² − a²)</p>
                <p>Intersection P₁, P₂, choose the one with y ≥ 0 as B.</p>
            </div>`;
        } else {
            html += `
            <h3>Axis mode</h3>
            <div class="eq small">
                <p>A = (0, 0), C = (AC, 0)</p>
                <p>Given BC and ∠C,</p>
                <p>B.x = C.x − BC·cos(∠C)</p>
                <p>B.y = BC·sin(∠C)</p>
            </div>`;
        }

        if (!showDebugEl.checked) {
            html += `<p class="small">Debug visualiser is OFF — only triangle ABC is drawn.</p>`;
        }

        resultsPanel.innerHTML = html;

        drawScene(A, B, C, debugData);
    }

    function clearCanvas() {
        const w = canvas.clientWidth || 600;
        canvas.width = w;
        canvas.height = w * 0.5;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // ---------- drawing ----------
    function drawScene(A, B, C, debugData) {
        const showDebug = showDebugEl.checked;

        // Collect points for bounding box
        let pts = [A, B, C];

        if (showDebug && debugData.mode === "driven") {
            const { rA, rC } = debugData;
            pts.push(
                {x:A.x+rA, y:A.y}, {x:A.x-rA, y:A.y},
                {x:A.x,    y:A.y+rA}, {x:A.x, y:A.y-rA},
                {x:C.x+rC, y:C.y}, {x:C.x-rC, y:C.y},
                {x:C.x,    y:C.y+rC}, {x:C.x, y:C.y-rC}
            );
        }

        let minX = Math.min(...pts.map(p => p.x));
        let maxX = Math.max(...pts.map(p => p.x));
        let minY = Math.min(...pts.map(p => p.y));
        let maxY = Math.max(...pts.map(p => p.y));

        const zoomPadding = 1;
        minX -= zoomPadding;
        maxX += zoomPadding;
        minY = Math.min(minY, 0) - zoomPadding;
        maxY += zoomPadding;

        const boxW = maxX - minX;
        const boxH = maxY - minY;
        const canvasW = canvas.clientWidth || 600;
        const scale = canvasW / boxW;
        const canvasH = boxH * scale;

        canvas.width = canvasW;
        canvas.height = canvasH;

        function TX(x) { return (x - minX) * scale; }
        function TY(y) { return canvasH - (y - minY) * scale; }

        ctx.clearRect(0, 0, canvasW, canvasH);

        // Grid
        if (showDebug) {
            drawGrid(ctx, minX, maxX, minY, maxY, TX, TY, canvasW, canvasH);
        }

        // Baseline AC
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#555";
        ctx.beginPath();
        ctx.moveTo(TX(A.x), TY(A.y));
        ctx.lineTo(TX(C.x), TY(C.y));
        ctx.stroke();

        // Triangle ABC
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#ddd";
        ctx.beginPath();
        ctx.moveTo(TX(A.x), TY(A.y));
        ctx.lineTo(TX(B.x), TY(B.y));
        ctx.lineTo(TX(C.x), TY(C.y));
        ctx.stroke();

        // Points
        function dot(p, col, r=6){
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.arc(TX(p.x), TY(p.y), r, 0, Math.PI*2);
            ctx.fill();
        }

        dot(A, "#4aa3ff");
        dot(B, "#ff5555", 7);
        dot(C, "#ffcc33");

        // ABC labels (kept exactly as before)
        if (showDebug) {
            ctx.fillStyle = "#fff";
            ctx.font = "14px Arial";
            ctx.fillText("A", TX(A.x)-10, TY(A.y)+16);
            ctx.fillText("C", TX(C.x)+6, TY(C.y)+16);
            ctx.fillText("B", TX(B.x)-5, TY(B.y)-10);
        }

        // Circles for driven mode
        if (showDebug && debugData.mode === "driven") {
            const { rA, rC } = debugData;

            ctx.strokeStyle = "#4aa3ff";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(TX(A.x), TY(A.y), rA*scale, 0, Math.PI*2);
            ctx.stroke();

            ctx.strokeStyle = "#ffcc33";
            ctx.beginPath();
            ctx.arc(TX(C.x), TY(C.y), rC*scale, 0, Math.PI*2);
            ctx.stroke();
        }

        // --- Debug text (Angle C, AB, BC) ---
        if (showDebug) {
            const AB = dist(A, B);
            const BC = dist(B, C);

            // Midpoints of each line
            const midAB = { x: (A.x + B.x) / 2, y: (A.y + B.y) / 2 };
            const midBC = { x: (B.x + C.x) / 2, y: (B.y + C.y) / 2 };

            // Angle C (same as results)
            const AC = dist(A, C);
            const angleC = Math.acos((AC*AC + BC*BC - AB*AB) / (2*AC*BC)) * (180/Math.PI);

            ctx.fillStyle = "#fff";
            ctx.font = "14px Arial";

            // AB length at midpoint
            ctx.fillText(
                `AB: ${AB.toFixed(3)}`,
                TX(midAB.x) + 5,
                TY(midAB.y) - 5
            );

            // BC length at midpoint
            ctx.fillText(
                `BC: ${BC.toFixed(3)}`,
                TX(midBC.x) + 5,
                TY(midBC.y) - 5
            );

            // --- Angle displayed to the RIGHT of point C ---
            ctx.fillText(
                `${angleC.toFixed(2)}°`,
                TX(C.x) + 18,
                TY(C.y) - 6
            );
        }
    }

    function drawPoint(x, y, r) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, 2*Math.PI);
        ctx.fill();
    }

    function drawGrid(ctx, minX, maxX, minY, maxY, TX, TY, w, h) {
        const majorStep = 1;
        const minorStep = 0.2;

        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        // minor vertical
        for (let x = Math.ceil(minX/minorStep)*minorStep; x <= maxX; x += minorStep) {
            ctx.beginPath();
            ctx.moveTo(TX(x), TY(minY));
            ctx.lineTo(TX(x), TY(maxY));
            ctx.stroke();
        }
        // minor horizontal
        for (let y = Math.ceil(minY/minorStep)*minorStep; y <= maxY; y += minorStep) {
            ctx.beginPath();
            ctx.moveTo(TX(minX), TY(y));
            ctx.lineTo(TX(maxX), TY(y));
            ctx.stroke();
        }

        // major
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        for (let x = Math.ceil(minX/majorStep)*majorStep; x <= maxX; x += majorStep) {
            ctx.beginPath();
            ctx.moveTo(TX(x), TY(minY));
            ctx.lineTo(TX(x), TY(maxY));
            ctx.stroke();
        }
        for (let y = Math.ceil(minY/majorStep)*majorStep; y <= maxY; y += majorStep) {
            ctx.beginPath();
            ctx.moveTo(TX(minX), TY(y));
            ctx.lineTo(TX(maxX), TY(y));
            ctx.stroke();
        }

        // x-axis (y=0)
        if (minY <= 0 && maxY >= 0) {
            ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(TX(minX), TY(0));
            ctx.lineTo(TX(maxX), TY(0));
            ctx.stroke();
        }
    }

    // ---------- wire up ----------
    [
        modeEl, showDebugEl,
        lenACEl, radAEl, radCEl,
        lenBCEl, angleCEl
    ].forEach(el => el.addEventListener("input", update));

    window.addEventListener("load", update);
</script>

</body>
</html>
